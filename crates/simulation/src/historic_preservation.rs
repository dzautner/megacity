//! Historic Preservation Districts (ZONE-008).
//!
//! Allows the player to designate districts as historic preservation zones.
//! Buildings in historic districts:
//! - Cannot be demolished, upgraded, or replaced
//! - Are frozen at their current building level
//! - Generate a +10% land value bonus for cells in the district
//! - Generate tourism visits (historic districts attract tourists)
//!
//! Removing historic preservation from a district triggers a happiness
//! penalty from preservationist citizens.

use bevy::prelude::*;
use bitcode::{Decode, Encode};
use std::collections::HashSet;

use crate::config::{GRID_HEIGHT, GRID_WIDTH};
use crate::districts::DistrictMap;
use crate::land_value::LandValueGrid;
use crate::tourism::Tourism;
use crate::SlowTickTimer;

// =============================================================================
// Constants
// =============================================================================

/// Land value bonus multiplier for cells in a historic district (+10%).
pub const HISTORIC_LAND_VALUE_BONUS: f32 = 0.10;

/// Base monthly tourism visitors generated per historic district.
pub const HISTORIC_TOURISM_VISITORS_PER_DISTRICT: u32 = 200;

/// Happiness penalty applied when historic preservation is removed from a district.
pub const PRESERVATION_REMOVAL_HAPPINESS_PENALTY: f32 = 8.0;

/// Number of ticks that the removal happiness penalty lasts.
pub const REMOVAL_PENALTY_DURATION_TICKS: u32 = 300;

// =============================================================================
// Resource: Historic Preservation State
// =============================================================================

/// Tracks which player-defined districts have historic preservation enabled,
/// and any active removal penalties.
#[derive(Resource, Debug, Clone, Default, Encode, Decode)]
pub struct HistoricPreservationState {
    /// Set of district indices that have historic preservation enabled.
    pub preserved_districts: HashSet<usize>,
    /// Active removal penalties: (district_index, remaining_ticks).
    pub removal_penalties: Vec<(usize, u32)>,
    /// Total tourism visitors generated by historic districts this period.
    pub historic_tourism_visitors: u32,
}

impl HistoricPreservationState {
    /// Check if a district is designated as a historic preservation district.
    pub fn is_preserved(&self, district_idx: usize) -> bool {
        self.preserved_districts.contains(&district_idx)
    }

    /// Designate a district as historic preservation.
    pub fn designate(&mut self, district_idx: usize) {
        self.preserved_districts.insert(district_idx);
    }

    /// Remove historic preservation from a district, triggering a removal penalty.
    pub fn remove(&mut self, district_idx: usize) {
        if self.preserved_districts.remove(&district_idx) {
            self.removal_penalties
                .push((district_idx, REMOVAL_PENALTY_DURATION_TICKS));
        }
    }

    /// Check if a cell at (x, y) is in a historic preservation district.
    pub fn is_cell_preserved(&self, x: usize, y: usize, district_map: &DistrictMap) -> bool {
        if let Some(di) = district_map.get_district_index_at(x, y) {
            self.preserved_districts.contains(&di)
        } else {
            false
        }
    }

    /// Get the current happiness penalty from removal events.
    pub fn removal_happiness_penalty(&self) -> f32 {
        if self.removal_penalties.is_empty() {
            return 0.0;
        }
        // Each active removal contributes a decaying penalty
        let mut total = 0.0_f32;
        for &(_, remaining) in &self.removal_penalties {
            let fraction = remaining as f32 / REMOVAL_PENALTY_DURATION_TICKS as f32;
            total += PRESERVATION_REMOVAL_HAPPINESS_PENALTY * fraction;
        }
        total
    }
}

// =============================================================================
// Pure helper functions (testable without ECS)
// =============================================================================

/// Calculate the land value bonus for a cell in a historic district.
/// Returns the bonus as an integer to add to the current land value.
pub fn historic_land_value_bonus(current_value: u8) -> i32 {
    (current_value as f32 * HISTORIC_LAND_VALUE_BONUS) as i32
}

/// Calculate tourism visitors from historic districts.
pub fn calculate_historic_tourism(num_preserved_districts: usize) -> u32 {
    num_preserved_districts as u32 * HISTORIC_TOURISM_VISITORS_PER_DISTRICT
}

/// Check if a building should be protected from upgrade/demolition.
pub fn is_building_protected(
    building_x: usize,
    building_y: usize,
    state: &HistoricPreservationState,
    district_map: &DistrictMap,
) -> bool {
    state.is_cell_preserved(building_x, building_y, district_map)
}

// =============================================================================
// Systems
// =============================================================================

/// Apply land value bonuses for cells in historic preservation districts.
/// Runs on the slow tick timer to align with land value updates.
pub fn apply_historic_land_value_bonus(
    slow_timer: Res<SlowTickTimer>,
    preservation: Res<HistoricPreservationState>,
    district_map: Res<DistrictMap>,
    mut land_value: ResMut<LandValueGrid>,
) {
    if !slow_timer.should_run() {
        return;
    }

    if preservation.preserved_districts.is_empty() {
        return;
    }

    // For each preserved district, boost land values in its cells
    for &di in &preservation.preserved_districts {
        if di >= district_map.districts.len() {
            continue;
        }
        for &(cx, cy) in &district_map.districts[di].cells {
            if cx < GRID_WIDTH && cy < GRID_HEIGHT {
                let cur = land_value.get(cx, cy);
                let bonus = historic_land_value_bonus(cur);
                let new_val = (cur as i32 + bonus).min(255) as u8;
                land_value.set(cx, cy, new_val);
            }
        }
    }
}

/// Update tourism from historic districts.
/// Runs on the slow tick timer.
pub fn update_historic_tourism(
    slow_timer: Res<SlowTickTimer>,
    mut preservation: ResMut<HistoricPreservationState>,
    mut tourism: ResMut<Tourism>,
) {
    if !slow_timer.should_run() {
        return;
    }

    let visitors = calculate_historic_tourism(preservation.preserved_districts.len());
    preservation.historic_tourism_visitors = visitors;

    // Add historic district visitors to overall tourism
    tourism.monthly_visitors += visitors;
    tourism.monthly_tourism_income += visitors as f64 * 1.5; // $1.50 per historic tourist
}

/// Decay removal penalties over time.
pub fn decay_removal_penalties(
    slow_timer: Res<SlowTickTimer>,
    mut preservation: ResMut<HistoricPreservationState>,
) {
    if !slow_timer.should_run() {
        return;
    }

    // Decay each penalty and remove expired ones
    preservation
        .removal_penalties
        .retain_mut(|(_di, remaining)| {
            *remaining = remaining.saturating_sub(1);
            *remaining > 0
        });
}

// =============================================================================
// Saveable implementation
// =============================================================================

impl crate::Saveable for HistoricPreservationState {
    const SAVE_KEY: &'static str = "historic_preservation";

    fn save_to_bytes(&self) -> Option<Vec<u8>> {
        // Skip saving if no districts are preserved and no penalties are active
        if self.preserved_districts.is_empty() && self.removal_penalties.is_empty() {
            return None;
        }
        Some(bitcode::encode(self))
    }

    fn load_from_bytes(bytes: &[u8]) -> Self {
        bitcode::decode(bytes).unwrap_or_default()
    }
}

// =============================================================================
// Plugin
// =============================================================================

pub struct HistoricPreservationPlugin;

impl Plugin for HistoricPreservationPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<HistoricPreservationState>()
            .add_systems(
                FixedUpdate,
                (
                    apply_historic_land_value_bonus.after(crate::land_value::update_land_value),
                    update_historic_tourism.after(crate::tourism::update_tourism),
                    decay_removal_penalties,
                ),
            );

        // Register for save/load via the SaveableRegistry.
        app.init_resource::<crate::SaveableRegistry>();
        app.world_mut()
            .resource_mut::<crate::SaveableRegistry>()
            .register::<HistoricPreservationState>();
    }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    // -------------------------------------------------------------------------
    // Default state tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_default_state() {
        let state = HistoricPreservationState::default();
        assert!(state.preserved_districts.is_empty());
        assert!(state.removal_penalties.is_empty());
        assert_eq!(state.historic_tourism_visitors, 0);
    }

    // -------------------------------------------------------------------------
    // Designation and removal tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_designate_district() {
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        assert!(state.is_preserved(0));
        assert!(!state.is_preserved(1));
    }

    #[test]
    fn test_designate_multiple_districts() {
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        state.designate(3);
        state.designate(5);
        assert!(state.is_preserved(0));
        assert!(state.is_preserved(3));
        assert!(state.is_preserved(5));
        assert!(!state.is_preserved(1));
        assert_eq!(state.preserved_districts.len(), 3);
    }

    #[test]
    fn test_designate_idempotent() {
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        state.designate(0);
        assert_eq!(state.preserved_districts.len(), 1);
    }

    #[test]
    fn test_remove_designation() {
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        state.remove(0);
        assert!(!state.is_preserved(0));
        assert_eq!(state.removal_penalties.len(), 1);
    }

    #[test]
    fn test_remove_nonexistent_no_penalty() {
        let mut state = HistoricPreservationState::default();
        state.remove(5); // never designated
        assert!(state.removal_penalties.is_empty());
    }

    // -------------------------------------------------------------------------
    // Cell preservation tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_is_cell_preserved() {
        let mut state = HistoricPreservationState::default();
        let mut district_map = DistrictMap::default();

        // Assign cell (10, 10) to district 0
        district_map.assign_cell_to_district(10, 10, 0);

        // Not preserved yet
        assert!(!state.is_cell_preserved(10, 10, &district_map));

        // Designate district 0
        state.designate(0);
        assert!(state.is_cell_preserved(10, 10, &district_map));

        // Cell not in any district
        assert!(!state.is_cell_preserved(100, 100, &district_map));
    }

    // -------------------------------------------------------------------------
    // Building protection tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_is_building_protected() {
        let mut state = HistoricPreservationState::default();
        let mut district_map = DistrictMap::default();

        district_map.assign_cell_to_district(10, 10, 0);
        assert!(!is_building_protected(10, 10, &state, &district_map));

        state.designate(0);
        assert!(is_building_protected(10, 10, &state, &district_map));
    }

    #[test]
    fn test_building_not_protected_outside_district() {
        let mut state = HistoricPreservationState::default();
        let district_map = DistrictMap::default();

        state.designate(0);
        // Cell (200, 200) is not assigned to any district
        assert!(!is_building_protected(200, 200, &state, &district_map));
    }

    // -------------------------------------------------------------------------
    // Land value bonus tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_historic_land_value_bonus_calculation() {
        // 10% of 100 = 10
        assert_eq!(historic_land_value_bonus(100), 10);
        // 10% of 50 = 5
        assert_eq!(historic_land_value_bonus(50), 5);
        // 10% of 0 = 0
        assert_eq!(historic_land_value_bonus(0), 0);
        // 10% of 255 = 25
        assert_eq!(historic_land_value_bonus(255), 25);
    }

    // -------------------------------------------------------------------------
    // Tourism tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_historic_tourism_none() {
        assert_eq!(calculate_historic_tourism(0), 0);
    }

    #[test]
    fn test_historic_tourism_one_district() {
        assert_eq!(
            calculate_historic_tourism(1),
            HISTORIC_TOURISM_VISITORS_PER_DISTRICT
        );
    }

    #[test]
    fn test_historic_tourism_multiple_districts() {
        assert_eq!(
            calculate_historic_tourism(3),
            3 * HISTORIC_TOURISM_VISITORS_PER_DISTRICT
        );
    }

    // -------------------------------------------------------------------------
    // Removal penalty tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_removal_penalty_initial() {
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        state.remove(0);

        let penalty = state.removal_happiness_penalty();
        assert!(
            (penalty - PRESERVATION_REMOVAL_HAPPINESS_PENALTY).abs() < f32::EPSILON,
            "initial penalty should be full: {}",
            penalty
        );
    }

    #[test]
    fn test_removal_penalty_decays() {
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        state.remove(0);

        // Simulate half decay
        state.removal_penalties[0].1 = REMOVAL_PENALTY_DURATION_TICKS / 2;
        let penalty = state.removal_happiness_penalty();
        let expected = PRESERVATION_REMOVAL_HAPPINESS_PENALTY * 0.5;
        assert!(
            (penalty - expected).abs() < 0.1,
            "half-decayed penalty should be ~{}: got {}",
            expected,
            penalty
        );
    }

    #[test]
    fn test_removal_penalty_none_when_empty() {
        let state = HistoricPreservationState::default();
        assert_eq!(state.removal_happiness_penalty(), 0.0);
    }

    #[test]
    fn test_multiple_removal_penalties_stack() {
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        state.designate(1);
        state.remove(0);
        state.remove(1);

        let penalty = state.removal_happiness_penalty();
        let expected = PRESERVATION_REMOVAL_HAPPINESS_PENALTY * 2.0;
        assert!(
            (penalty - expected).abs() < f32::EPSILON,
            "two removals should double penalty: got {}",
            penalty
        );
    }

    // -------------------------------------------------------------------------
    // Saveable trait tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_saveable_skips_default() {
        use crate::Saveable;
        let state = HistoricPreservationState::default();
        assert!(state.save_to_bytes().is_none());
    }

    #[test]
    fn test_saveable_saves_when_active() {
        use crate::Saveable;
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        assert!(state.save_to_bytes().is_some());
    }

    #[test]
    fn test_saveable_roundtrip() {
        use crate::Saveable;
        let mut state = HistoricPreservationState::default();
        state.designate(0);
        state.designate(3);
        state
            .removal_penalties
            .push((5, REMOVAL_PENALTY_DURATION_TICKS));
        state.historic_tourism_visitors = 400;

        let bytes = state.save_to_bytes().expect("should serialize");
        let restored = HistoricPreservationState::load_from_bytes(&bytes);

        assert!(restored.is_preserved(0));
        assert!(restored.is_preserved(3));
        assert!(!restored.is_preserved(1));
        assert_eq!(restored.removal_penalties.len(), 1);
        assert_eq!(restored.removal_penalties[0].0, 5);
        assert_eq!(
            restored.removal_penalties[0].1,
            REMOVAL_PENALTY_DURATION_TICKS
        );
    }

    #[test]
    fn test_saveable_key() {
        use crate::Saveable;
        assert_eq!(HistoricPreservationState::SAVE_KEY, "historic_preservation");
    }

    #[test]
    fn test_saveable_saves_with_penalty_only() {
        use crate::Saveable;
        let mut state = HistoricPreservationState::default();
        // No preserved districts, but there's an active removal penalty
        state
            .removal_penalties
            .push((0, REMOVAL_PENALTY_DURATION_TICKS));
        assert!(state.save_to_bytes().is_some());
    }

    // -------------------------------------------------------------------------
    // Constants validation tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_constants_are_reasonable() {
        assert!(HISTORIC_LAND_VALUE_BONUS > 0.0);
        assert!(HISTORIC_LAND_VALUE_BONUS < 1.0);
        assert!(HISTORIC_TOURISM_VISITORS_PER_DISTRICT > 0);
        assert!(PRESERVATION_REMOVAL_HAPPINESS_PENALTY > 0.0);
        assert!(REMOVAL_PENALTY_DURATION_TICKS > 0);
    }
}
