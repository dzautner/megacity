//! Combined Sewer Overflow (CSO) events (WATER-009).
//!
//! In cities with combined sewer systems, a single pipe carries both sewage and
//! stormwater. During heavy rain, the combined flow can exceed treatment plant
//! capacity, forcing untreated discharge (CSO) into waterways.
//!
//! This module tracks the sewer system type (combined vs. separated), calculates
//! combined flow from population sewage and stormwater runoff, detects overflow
//! conditions, and emits `CsoEvent` Bevy events when CSO occurs. Separated sewers
//! route stormwater to storm drains independently, preventing CSO entirely.

use bevy::prelude::*;
use serde::{Deserialize, Serialize};

use crate::grid::{CellType, WorldGrid};
use crate::stormwater::StormwaterGrid;
use crate::SlowTickTimer;

// =============================================================================
// Constants
// =============================================================================

/// Average sewage flow per person per day, in gallons.
pub const GALLONS_PER_CAPITA_PER_DAY: f32 = 80.0;

/// Combined sewer capacity per road cell, in gallons per hour.
pub const BASE_COMBINED_CAPACITY_PER_CELL: f32 = 10_000.0;

/// Fraction of stormwater runoff that enters the combined sewer system.
/// The rest flows overland or into separate storm drains.
pub const STORMWATER_TO_SEWER_FACTOR: f32 = 0.5;

/// Pollution units generated per gallon of untreated CSO discharge.
pub const POLLUTION_PER_GALLON_CSO: f32 = 0.0001;

/// Cost in dollars to separate one grid cell from combined to separated sewer.
pub const SEPARATION_COST_PER_CELL: f32 = 500_000.0;

// =============================================================================
// SewerType enum
// =============================================================================

/// Whether the city uses a combined or separated sewer system.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SewerType {
    /// Single pipe carries both sewage and stormwater. Prone to CSO during storms.
    #[default]
    Combined,
    /// Separate pipes for sewage and stormwater. No CSO risk.
    Separated,
}

// =============================================================================
// SewerSystemState resource
// =============================================================================

/// City-wide sewer system state, tracking capacity, flow, and CSO events.
#[derive(Resource, Clone, Debug, Serialize, Deserialize)]
pub struct SewerSystemState {
    /// Whether the city primarily uses combined or separated sewers.
    pub sewer_type: SewerType,
    /// Total combined sewer capacity in gallons per hour.
    pub combined_capacity: f32,
    /// Current combined flow (sewage + stormwater inflow) in gallons per hour.
    pub current_flow: f32,
    /// Whether a CSO event is currently active (flow exceeds capacity).
    pub cso_active: bool,
    /// Gallons of untreated discharge this tick.
    pub cso_discharge_gallons: f32,
    /// Cumulative total CSO events since city founding.
    pub cso_events_total: u32,
    /// CSO events this calendar year (reset annually).
    pub cso_events_this_year: u32,
    /// Number of grid cells that have been upgraded to separated sewers.
    pub cells_with_separated_sewer: u32,
    /// Total number of sewer-serviced cells (road cells).
    pub total_sewer_cells: u32,
    /// Fraction of sewer cells that are separated (0.0..=1.0).
    pub separation_coverage: f32,
    /// Total gallons of CSO discharge this calendar year.
    pub annual_cso_volume: f32,
    /// Pollution units contributed by CSO this tick.
    pub pollution_contribution: f32,
}

impl Default for SewerSystemState {
    fn default() -> Self {
        Self {
            sewer_type: SewerType::Combined,
            combined_capacity: 0.0,
            current_flow: 0.0,
            cso_active: false,
            cso_discharge_gallons: 0.0,
            cso_events_total: 0,
            cso_events_this_year: 0,
            cells_with_separated_sewer: 0,
            total_sewer_cells: 0,
            separation_coverage: 0.0,
            annual_cso_volume: 0.0,
            pollution_contribution: 0.0,
        }
    }
}

// =============================================================================
// CsoEvent (Bevy Event)
// =============================================================================

/// Bevy event fired when a Combined Sewer Overflow occurs.
///
/// Downstream systems can listen for this event to apply water pollution,
/// trigger UI notifications, or update environmental compliance records.
#[derive(Event, Debug, Clone)]
pub struct CsoEvent {
    /// Gallons of untreated sewage+stormwater discharged.
    pub discharge_gallons: f32,
    /// Pollution units generated by this discharge.
    pub pollution_units: f32,
}

// =============================================================================
// Helper functions
// =============================================================================

/// Estimate the city's sewage flow in gallons per hour from population.
///
/// `sewage_gph = population * GALLONS_PER_CAPITA_PER_DAY / 24.0`
fn sewage_flow_gph(population: u32) -> f32 {
    population as f32 * GALLONS_PER_CAPITA_PER_DAY / 24.0
}

/// Calculate stormwater inflow to the combined sewer in gallons per hour.
///
/// Only a fraction (`STORMWATER_TO_SEWER_FACTOR`) of total runoff enters the
/// combined sewer; the remainder flows overland or into separate drainage.
fn stormwater_inflow_gph(total_runoff: f32) -> f32 {
    total_runoff * STORMWATER_TO_SEWER_FACTOR
}

/// Count road cells in the world grid (these represent sewer-serviced cells).
fn count_road_cells(grid: &WorldGrid) -> u32 {
    grid.cells
        .iter()
        .filter(|c| c.cell_type == CellType::Road)
        .count() as u32
}

/// Calculate the combined sewer capacity from road cells.
///
/// Only cells that are NOT separated contribute to combined sewer capacity.
/// Separated cells don't carry stormwater through the combined pipe.
fn calculate_combined_capacity(total_road_cells: u32, separated_cells: u32) -> f32 {
    let combined_cells = total_road_cells.saturating_sub(separated_cells);
    combined_cells as f32 * BASE_COMBINED_CAPACITY_PER_CELL
}

/// Calculate the effective combined flow.
///
/// For combined sewers: sewage + stormwater inflow.
/// For fully separated sewers: only sewage (stormwater goes to storm drains).
/// For partially separated: blended based on separation_coverage.
fn calculate_combined_flow(sewage_gph: f32, stormwater_gph: f32, separation_coverage: f32) -> f32 {
    // The unseparated fraction of the city still sends stormwater into the sewer.
    let unseparated_fraction = 1.0 - separation_coverage;
    sewage_gph + stormwater_gph * unseparated_fraction
}

// =============================================================================
// System
// =============================================================================

/// Main CSO update system. Runs on `SlowTickTimer`.
///
/// 1. Estimate sewage flow from population (gallons per capita per day / 24).
/// 2. Calculate stormwater inflow from `StormwaterGrid.total_runoff`.
/// 3. Combined flow = sewage + stormwater (adjusted for separation coverage).
/// 4. If combined flow > combined capacity: CSO occurs.
/// 5. CSO discharge = overflow (combined_flow - capacity).
/// 6. Separated sewers route stormwater to storm drains (no CSO contribution).
/// 7. Track CSO frequency for environmental compliance.
/// 8. Pollution contribution proportional to CSO discharge.
pub fn update_sewer_overflow(
    slow_timer: Res<SlowTickTimer>,
    mut sewer_state: ResMut<SewerSystemState>,
    grid: Res<WorldGrid>,
    stormwater: Res<StormwaterGrid>,
    mut cso_events: EventWriter<CsoEvent>,
) {
    if !slow_timer.should_run() {
        return;
    }

    // --- Phase 1: Count road cells and update sewer infrastructure stats ---
    let total_road_cells = count_road_cells(&grid);
    sewer_state.total_sewer_cells = total_road_cells;

    let separation_coverage = if total_road_cells > 0 {
        (sewer_state.cells_with_separated_sewer as f32 / total_road_cells as f32).clamp(0.0, 1.0)
    } else {
        0.0
    };
    sewer_state.separation_coverage = separation_coverage;

    // Update the sewer_type based on coverage threshold.
    // If >95% separated, consider the system as Separated.
    sewer_state.sewer_type = if separation_coverage > 0.95 {
        SewerType::Separated
    } else {
        SewerType::Combined
    };

    // --- Phase 2: Calculate combined sewer capacity ---
    let combined_capacity =
        calculate_combined_capacity(total_road_cells, sewer_state.cells_with_separated_sewer);
    sewer_state.combined_capacity = combined_capacity;

    // --- Phase 3: Estimate population from road cells ---
    // Use a rough population estimate: ~50 people per road cell as a proxy.
    // In a real integration this would come from CityStats, but we estimate here
    // to keep the module self-contained for the system signature.
    // A typical city has road cells roughly proportional to population.
    let estimated_population = total_road_cells * 50;

    // --- Phase 4: Calculate flows ---
    let sewage_gph = sewage_flow_gph(estimated_population);
    let stormwater_gph = stormwater_inflow_gph(stormwater.total_runoff);
    let combined_flow = calculate_combined_flow(sewage_gph, stormwater_gph, separation_coverage);
    sewer_state.current_flow = combined_flow;

    // --- Phase 5: Check for CSO ---
    if combined_flow > combined_capacity && combined_capacity > 0.0 {
        let discharge = combined_flow - combined_capacity;
        let pollution = discharge * POLLUTION_PER_GALLON_CSO;

        sewer_state.cso_active = true;
        sewer_state.cso_discharge_gallons = discharge;
        sewer_state.cso_events_total += 1;
        sewer_state.cso_events_this_year += 1;
        sewer_state.annual_cso_volume += discharge;
        sewer_state.pollution_contribution = pollution;

        // Fire a Bevy event so other systems can react
        cso_events.send(CsoEvent {
            discharge_gallons: discharge,
            pollution_units: pollution,
        });
    } else {
        // No overflow this tick
        sewer_state.cso_active = false;
        sewer_state.cso_discharge_gallons = 0.0;
        sewer_state.pollution_contribution = 0.0;
    }
}

// =============================================================================
// Tests
// =============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{GRID_HEIGHT, GRID_WIDTH};

    // -------------------------------------------------------------------------
    // SewerType tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_sewer_type_default_is_combined() {
        assert_eq!(SewerType::default(), SewerType::Combined);
    }

    #[test]
    fn test_sewer_type_equality() {
        assert_eq!(SewerType::Combined, SewerType::Combined);
        assert_eq!(SewerType::Separated, SewerType::Separated);
        assert_ne!(SewerType::Combined, SewerType::Separated);
    }

    #[test]
    fn test_sewer_type_clone() {
        let t = SewerType::Separated;
        let t2 = t;
        assert_eq!(t, t2);
    }

    #[test]
    fn test_sewer_type_serde_roundtrip() {
        let combined = SewerType::Combined;
        let json = serde_json::to_string(&combined).expect("serialize");
        let deserialized: SewerType = serde_json::from_str(&json).expect("deserialize");
        assert_eq!(deserialized, SewerType::Combined);

        let separated = SewerType::Separated;
        let json = serde_json::to_string(&separated).expect("serialize");
        let deserialized: SewerType = serde_json::from_str(&json).expect("deserialize");
        assert_eq!(deserialized, SewerType::Separated);
    }

    // -------------------------------------------------------------------------
    // SewerSystemState default tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_sewer_state_default() {
        let state = SewerSystemState::default();
        assert_eq!(state.sewer_type, SewerType::Combined);
        assert_eq!(state.combined_capacity, 0.0);
        assert_eq!(state.current_flow, 0.0);
        assert!(!state.cso_active);
        assert_eq!(state.cso_discharge_gallons, 0.0);
        assert_eq!(state.cso_events_total, 0);
        assert_eq!(state.cso_events_this_year, 0);
        assert_eq!(state.cells_with_separated_sewer, 0);
        assert_eq!(state.total_sewer_cells, 0);
        assert_eq!(state.separation_coverage, 0.0);
        assert_eq!(state.annual_cso_volume, 0.0);
        assert_eq!(state.pollution_contribution, 0.0);
    }

    #[test]
    fn test_sewer_state_clone() {
        let mut state = SewerSystemState::default();
        state.cso_events_total = 7;
        state.combined_capacity = 100_000.0;
        state.cso_active = true;
        let cloned = state.clone();
        assert_eq!(cloned.cso_events_total, 7);
        assert_eq!(cloned.combined_capacity, 100_000.0);
        assert!(cloned.cso_active);
    }

    #[test]
    fn test_sewer_state_serde_roundtrip() {
        let state = SewerSystemState {
            sewer_type: SewerType::Combined,
            combined_capacity: 500_000.0,
            current_flow: 300_000.0,
            cso_active: true,
            cso_discharge_gallons: 50_000.0,
            cso_events_total: 12,
            cso_events_this_year: 3,
            cells_with_separated_sewer: 100,
            total_sewer_cells: 400,
            separation_coverage: 0.25,
            annual_cso_volume: 150_000.0,
            pollution_contribution: 5.0,
        };

        let json = serde_json::to_string(&state).expect("serialize");
        let deserialized: SewerSystemState = serde_json::from_str(&json).expect("deserialize");

        assert_eq!(deserialized.sewer_type, SewerType::Combined);
        assert!((deserialized.combined_capacity - 500_000.0).abs() < f32::EPSILON);
        assert!((deserialized.current_flow - 300_000.0).abs() < f32::EPSILON);
        assert!(deserialized.cso_active);
        assert!((deserialized.cso_discharge_gallons - 50_000.0).abs() < f32::EPSILON);
        assert_eq!(deserialized.cso_events_total, 12);
        assert_eq!(deserialized.cso_events_this_year, 3);
        assert_eq!(deserialized.cells_with_separated_sewer, 100);
        assert_eq!(deserialized.total_sewer_cells, 400);
        assert!((deserialized.separation_coverage - 0.25).abs() < f32::EPSILON);
        assert!((deserialized.annual_cso_volume - 150_000.0).abs() < f32::EPSILON);
        assert!((deserialized.pollution_contribution - 5.0).abs() < f32::EPSILON);
    }

    // -------------------------------------------------------------------------
    // Constants tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_constants_positive() {
        assert!(GALLONS_PER_CAPITA_PER_DAY > 0.0);
        assert!(BASE_COMBINED_CAPACITY_PER_CELL > 0.0);
        assert!(STORMWATER_TO_SEWER_FACTOR > 0.0);
        assert!(STORMWATER_TO_SEWER_FACTOR <= 1.0);
        assert!(POLLUTION_PER_GALLON_CSO > 0.0);
        assert!(SEPARATION_COST_PER_CELL > 0.0);
    }

    #[test]
    fn test_gallons_per_capita_per_day_value() {
        assert!((GALLONS_PER_CAPITA_PER_DAY - 80.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_base_combined_capacity_per_cell_value() {
        assert!((BASE_COMBINED_CAPACITY_PER_CELL - 10_000.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_stormwater_to_sewer_factor_value() {
        assert!((STORMWATER_TO_SEWER_FACTOR - 0.5).abs() < f32::EPSILON);
    }

    #[test]
    fn test_pollution_per_gallon_cso_value() {
        assert!((POLLUTION_PER_GALLON_CSO - 0.0001).abs() < f32::EPSILON);
    }

    #[test]
    fn test_separation_cost_per_cell_value() {
        assert!((SEPARATION_COST_PER_CELL - 500_000.0).abs() < f32::EPSILON);
    }

    // -------------------------------------------------------------------------
    // Sewage flow calculation tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_sewage_flow_gph_zero_population() {
        let flow = sewage_flow_gph(0);
        assert_eq!(flow, 0.0);
    }

    #[test]
    fn test_sewage_flow_gph_single_person() {
        let flow = sewage_flow_gph(1);
        let expected = 80.0_f32 / 24.0_f32; // ~3.333 gallons/hr
        assert!((flow - expected).abs() < 0.01_f32);
    }

    #[test]
    fn test_sewage_flow_gph_thousand_people() {
        let flow = sewage_flow_gph(1000);
        let expected = 1000.0_f32 * 80.0_f32 / 24.0_f32; // ~3333.33 gallons/hr
        assert!((flow - expected).abs() < 0.1_f32);
    }

    #[test]
    fn test_sewage_flow_scales_linearly() {
        let flow_100 = sewage_flow_gph(100);
        let flow_200 = sewage_flow_gph(200);
        assert!((flow_200 - flow_100 * 2.0_f32).abs() < 0.01_f32);
    }

    // -------------------------------------------------------------------------
    // Stormwater inflow calculation tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_stormwater_inflow_zero_runoff() {
        let inflow = stormwater_inflow_gph(0.0);
        assert_eq!(inflow, 0.0);
    }

    #[test]
    fn test_stormwater_inflow_half_of_runoff() {
        let total_runoff = 10_000.0_f32;
        let inflow = stormwater_inflow_gph(total_runoff);
        let expected = total_runoff * 0.5;
        assert!((inflow - expected).abs() < f32::EPSILON);
    }

    #[test]
    fn test_stormwater_inflow_scales_linearly() {
        let inflow_a = stormwater_inflow_gph(5_000.0);
        let inflow_b = stormwater_inflow_gph(10_000.0);
        assert!((inflow_b - inflow_a * 2.0_f32).abs() < 0.01_f32);
    }

    // -------------------------------------------------------------------------
    // Road cell counting tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_count_road_cells_empty_grid() {
        let grid = WorldGrid::new(GRID_WIDTH, GRID_HEIGHT);
        // Default cells are Grass, so no road cells
        let count = count_road_cells(&grid);
        assert_eq!(count, 0);
    }

    #[test]
    fn test_count_road_cells_with_roads() {
        let mut grid = WorldGrid::new(GRID_WIDTH, GRID_HEIGHT);
        grid.get_mut(0, 0).cell_type = CellType::Road;
        grid.get_mut(1, 0).cell_type = CellType::Road;
        grid.get_mut(2, 0).cell_type = CellType::Road;
        let count = count_road_cells(&grid);
        assert_eq!(count, 3);
    }

    #[test]
    fn test_count_road_cells_ignores_water() {
        let mut grid = WorldGrid::new(GRID_WIDTH, GRID_HEIGHT);
        grid.get_mut(0, 0).cell_type = CellType::Road;
        grid.get_mut(1, 0).cell_type = CellType::Water;
        let count = count_road_cells(&grid);
        assert_eq!(count, 1);
    }

    // -------------------------------------------------------------------------
    // Combined capacity calculation tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_combined_capacity_no_roads() {
        let capacity = calculate_combined_capacity(0, 0);
        assert_eq!(capacity, 0.0);
    }

    #[test]
    fn test_combined_capacity_all_combined() {
        let capacity = calculate_combined_capacity(10, 0);
        let expected = 10.0 * BASE_COMBINED_CAPACITY_PER_CELL;
        assert!((capacity - expected).abs() < f32::EPSILON);
    }

    #[test]
    fn test_combined_capacity_partially_separated() {
        let capacity = calculate_combined_capacity(10, 3);
        // 7 combined cells remain
        let expected = 7.0 * BASE_COMBINED_CAPACITY_PER_CELL;
        assert!((capacity - expected).abs() < f32::EPSILON);
    }

    #[test]
    fn test_combined_capacity_fully_separated() {
        let capacity = calculate_combined_capacity(10, 10);
        // No combined cells remain
        assert_eq!(capacity, 0.0);
    }

    #[test]
    fn test_combined_capacity_separated_exceeds_total() {
        // Edge case: separated cells > total (shouldn't happen but must not panic)
        let capacity = calculate_combined_capacity(5, 10);
        assert_eq!(capacity, 0.0);
    }

    // -------------------------------------------------------------------------
    // Combined flow calculation tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_combined_flow_no_separation() {
        let sewage = 1000.0_f32;
        let stormwater = 500.0_f32;
        let flow = calculate_combined_flow(sewage, stormwater, 0.0);
        // 0% separated => 100% stormwater enters sewer
        assert!((flow - 1500.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_combined_flow_full_separation() {
        let sewage = 1000.0_f32;
        let stormwater = 500.0_f32;
        let flow = calculate_combined_flow(sewage, stormwater, 1.0);
        // 100% separated => 0% stormwater enters sewer
        assert!((flow - 1000.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_combined_flow_half_separation() {
        let sewage = 1000.0_f32;
        let stormwater = 500.0_f32;
        let flow = calculate_combined_flow(sewage, stormwater, 0.5);
        // 50% separated => 50% stormwater enters sewer
        let expected = 1000.0_f32 + 500.0_f32 * 0.5_f32;
        assert!((flow - expected).abs() < f32::EPSILON);
    }

    #[test]
    fn test_combined_flow_zero_stormwater() {
        let sewage = 1000.0_f32;
        let flow = calculate_combined_flow(sewage, 0.0, 0.0);
        // Only sewage
        assert!((flow - 1000.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_combined_flow_zero_sewage() {
        let stormwater = 500.0_f32;
        let flow = calculate_combined_flow(0.0, stormwater, 0.0);
        // Only stormwater
        assert!((flow - 500.0).abs() < f32::EPSILON);
    }

    // -------------------------------------------------------------------------
    // CSO overflow detection tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_cso_occurs_when_flow_exceeds_capacity() {
        let combined_flow = 120_000.0_f32;
        let combined_capacity = 100_000.0_f32;
        let overflow = combined_flow > combined_capacity;
        assert!(overflow);
        let discharge = combined_flow - combined_capacity;
        assert!((discharge - 20_000.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_no_cso_when_flow_under_capacity() {
        let combined_flow = 80_000.0_f32;
        let combined_capacity = 100_000.0_f32;
        let overflow = combined_flow > combined_capacity;
        assert!(!overflow);
    }

    #[test]
    fn test_no_cso_at_exact_capacity() {
        let combined_flow = 100_000.0_f32;
        let combined_capacity = 100_000.0_f32;
        let overflow = combined_flow > combined_capacity;
        assert!(!overflow);
    }

    #[test]
    fn test_cso_discharge_equals_overflow() {
        let combined_flow = 150_000.0_f32;
        let combined_capacity = 100_000.0_f32;
        let discharge = (combined_flow - combined_capacity).max(0.0_f32);
        assert!((discharge - 50_000.0).abs() < f32::EPSILON);
    }

    // -------------------------------------------------------------------------
    // Pollution contribution tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_pollution_from_cso_discharge() {
        let discharge = 100_000.0_f32;
        let pollution = discharge * POLLUTION_PER_GALLON_CSO;
        let expected = 100_000.0 * 0.0001; // 10.0
        assert!((pollution - expected).abs() < f32::EPSILON);
    }

    #[test]
    fn test_pollution_zero_when_no_discharge() {
        let discharge = 0.0_f32;
        let pollution = discharge * POLLUTION_PER_GALLON_CSO;
        assert_eq!(pollution, 0.0);
    }

    #[test]
    fn test_pollution_scales_with_discharge() {
        let discharge_a = 50_000.0_f32;
        let discharge_b = 100_000.0_f32;
        let pollution_a = discharge_a * POLLUTION_PER_GALLON_CSO;
        let pollution_b = discharge_b * POLLUTION_PER_GALLON_CSO;
        assert!((pollution_b - pollution_a * 2.0_f32).abs() < 0.001_f32);
    }

    // -------------------------------------------------------------------------
    // Separation coverage calculation tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_separation_coverage_zero_when_no_roads() {
        let total_road_cells = 0u32;
        let separated = 0u32;
        let coverage = if total_road_cells > 0 {
            (separated as f32 / total_road_cells as f32).clamp(0.0, 1.0)
        } else {
            0.0
        };
        assert_eq!(coverage, 0.0);
    }

    #[test]
    fn test_separation_coverage_partial() {
        let total_road_cells = 100u32;
        let separated = 25u32;
        let coverage = (separated as f32 / total_road_cells as f32).clamp(0.0, 1.0);
        assert!((coverage - 0.25).abs() < f32::EPSILON);
    }

    #[test]
    fn test_separation_coverage_full() {
        let total_road_cells = 100u32;
        let separated = 100u32;
        let coverage = (separated as f32 / total_road_cells as f32).clamp(0.0, 1.0);
        assert!((coverage - 1.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_separation_coverage_clamped_above_one() {
        // Edge case: more separated cells than total (data corruption guard)
        let total_road_cells = 50u32;
        let separated = 75u32;
        let coverage = (separated as f32 / total_road_cells as f32).clamp(0.0, 1.0);
        assert!((coverage - 1.0).abs() < f32::EPSILON);
    }

    // -------------------------------------------------------------------------
    // Sewer type determination tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_sewer_type_combined_when_low_separation() {
        let separation_coverage = 0.50_f32;
        let sewer_type = if separation_coverage > 0.95 {
            SewerType::Separated
        } else {
            SewerType::Combined
        };
        assert_eq!(sewer_type, SewerType::Combined);
    }

    #[test]
    fn test_sewer_type_separated_when_high_separation() {
        let separation_coverage = 0.96_f32;
        let sewer_type = if separation_coverage > 0.95 {
            SewerType::Separated
        } else {
            SewerType::Combined
        };
        assert_eq!(sewer_type, SewerType::Separated);
    }

    #[test]
    fn test_sewer_type_combined_at_boundary() {
        let separation_coverage = 0.95_f32;
        let sewer_type = if separation_coverage > 0.95 {
            SewerType::Separated
        } else {
            SewerType::Combined
        };
        assert_eq!(sewer_type, SewerType::Combined);
    }

    // -------------------------------------------------------------------------
    // CsoEvent tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_cso_event_construction() {
        let event = CsoEvent {
            discharge_gallons: 25_000.0,
            pollution_units: 2.5,
        };
        assert!((event.discharge_gallons - 25_000.0).abs() < f32::EPSILON);
        assert!((event.pollution_units - 2.5).abs() < f32::EPSILON);
    }

    #[test]
    fn test_cso_event_clone() {
        let event = CsoEvent {
            discharge_gallons: 10_000.0,
            pollution_units: 1.0,
        };
        let cloned = event.clone();
        assert!((cloned.discharge_gallons - 10_000.0).abs() < f32::EPSILON);
        assert!((cloned.pollution_units - 1.0).abs() < f32::EPSILON);
    }

    // -------------------------------------------------------------------------
    // Integration-style tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_full_cso_cycle_dry_weather() {
        // No stormwater runoff => sewage only, well under capacity
        let population = 1000;
        let road_cells = 100u32;
        let separated = 0u32;

        let sewage = sewage_flow_gph(population);
        let stormwater = stormwater_inflow_gph(0.0);
        let capacity = calculate_combined_capacity(road_cells, separated);
        let separation_coverage = 0.0_f32;
        let flow = calculate_combined_flow(sewage, stormwater, separation_coverage);

        // Sewage: 1000 * 80 / 24 = ~3333 gph
        // Capacity: 100 * 10000 = 1,000,000 gph
        assert!(flow < capacity, "Dry weather should not cause CSO");
        assert!((stormwater - 0.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_full_cso_cycle_storm_event() {
        // Heavy storm with large stormwater inflow overwhelming capacity
        let population = 5000;
        let road_cells = 10u32; // small sewer system
        let separated = 0u32;

        let sewage = sewage_flow_gph(population);
        let total_runoff = 500_000.0_f32; // heavy storm
        let stormwater = stormwater_inflow_gph(total_runoff);
        let capacity = calculate_combined_capacity(road_cells, separated);
        let separation_coverage = 0.0_f32;
        let flow = calculate_combined_flow(sewage, stormwater, separation_coverage);

        // Capacity: 10 * 10000 = 100,000 gph
        // Flow: ~16,667 (sewage) + 250,000 (stormwater) = ~266,667 gph
        assert!(
            flow > capacity,
            "Storm should cause CSO: flow {} > capacity {}",
            flow,
            capacity
        );

        let discharge = flow - capacity;
        let pollution = discharge * POLLUTION_PER_GALLON_CSO;
        assert!(discharge > 0.0);
        assert!(pollution > 0.0);
    }

    #[test]
    fn test_full_cso_cycle_separated_system() {
        // Same storm, but fully separated sewers => no CSO
        let population = 5000;
        let road_cells = 10u32;
        let separated = 10u32; // fully separated

        let sewage = sewage_flow_gph(population);
        let total_runoff = 500_000.0_f32;
        let stormwater = stormwater_inflow_gph(total_runoff);

        let separation_coverage = (separated as f32 / road_cells as f32).clamp(0.0, 1.0);
        assert!((separation_coverage - 1.0).abs() < f32::EPSILON);

        // Capacity is 0 for combined (all separated), but flow also has no stormwater
        let flow = calculate_combined_flow(sewage, stormwater, separation_coverage);

        // With 100% separation, stormwater contribution is 0
        // Flow = sewage only = 5000 * 80 / 24 = ~16,667 gph
        // Combined capacity = 0 (all cells are separated)
        // But the separated system handles sewage through its own pipes,
        // so the combined system has 0 capacity and only sewage flow.
        // In practice, the separated system would have its own capacity,
        // but from the combined sewer perspective, there's no combined infrastructure.
        // This edge case shows that a fully separated city effectively eliminates
        // the concept of combined capacity entirely.
        assert!((flow - sewage).abs() < 0.1_f32);
    }

    #[test]
    fn test_partial_separation_reduces_cso() {
        let population = 5000;
        let road_cells = 20u32;
        let total_runoff = 500_000.0_f32;

        // No separation
        let sewage = sewage_flow_gph(population);
        let stormwater = stormwater_inflow_gph(total_runoff);
        let capacity_0 = calculate_combined_capacity(road_cells, 0);
        let flow_0 = calculate_combined_flow(sewage, stormwater, 0.0);
        let discharge_0 = (flow_0 - capacity_0).max(0.0_f32);

        // 50% separation
        let capacity_50 = calculate_combined_capacity(road_cells, 10);
        let flow_50 = calculate_combined_flow(sewage, stormwater, 0.5);
        let discharge_50 = (flow_50 - capacity_50).max(0.0_f32);

        // With partial separation, stormwater entering the combined sewer is halved,
        // but capacity is also halved. The net effect on CSO depends on the balance.
        // The key property: stormwater contribution to combined flow decreases.
        assert!(
            flow_50 < flow_0,
            "Partial separation should reduce combined flow"
        );
    }

    #[test]
    fn test_annual_cso_volume_accumulates() {
        let mut state = SewerSystemState::default();
        state.annual_cso_volume = 100_000.0;

        // Simulate another CSO event
        let new_discharge = 25_000.0_f32;
        state.annual_cso_volume += new_discharge;

        assert!((state.annual_cso_volume - 125_000.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_cso_event_counters_increment() {
        let mut state = SewerSystemState::default();
        assert_eq!(state.cso_events_total, 0);
        assert_eq!(state.cso_events_this_year, 0);

        // Simulate 3 CSO events
        for _ in 0..3 {
            state.cso_events_total += 1;
            state.cso_events_this_year += 1;
        }

        assert_eq!(state.cso_events_total, 3);
        assert_eq!(state.cso_events_this_year, 3);

        // Annual reset
        state.cso_events_this_year = 0;
        assert_eq!(state.cso_events_total, 3);
        assert_eq!(state.cso_events_this_year, 0);
    }

    #[test]
    fn test_zero_capacity_no_cso_when_no_flow() {
        // Edge case: no road cells means no capacity AND no population
        let capacity = calculate_combined_capacity(0, 0);
        let flow = calculate_combined_flow(0.0, 0.0, 0.0);
        // Flow does not exceed capacity (both zero)
        assert!(!(flow > capacity && capacity > 0.0));
    }

    #[test]
    fn test_separation_cost_for_city() {
        // Cost to separate 100 cells
        let cells_to_separate = 100u32;
        let total_cost = cells_to_separate as f32 * SEPARATION_COST_PER_CELL;
        assert!((total_cost - 50_000_000.0).abs() < f32::EPSILON);
    }
}

pub struct CsoPlugin;

impl Plugin for CsoPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<SewerSystemState>()
            .add_event::<CsoEvent>()
            .add_systems(
                FixedUpdate,
                update_sewer_overflow
                    .after(crate::imports_exports::process_trade)
                    .in_set(crate::SimulationSet::Simulation),
            );
    }
}
