//! Types, constants, and pure helper functions for historic preservation.

use bitcode::{Decode, Encode};
use std::collections::HashSet;

use bevy::prelude::*;

use crate::districts::DistrictMap;

// =============================================================================
// Constants
// =============================================================================

/// Land value bonus multiplier for cells in a historic district (+10%).
pub const HISTORIC_LAND_VALUE_BONUS: f32 = 0.10;

/// Base monthly tourism visitors generated per historic district.
pub const HISTORIC_TOURISM_VISITORS_PER_DISTRICT: u32 = 200;

/// Happiness penalty applied when historic preservation is removed from a district.
pub const PRESERVATION_REMOVAL_HAPPINESS_PENALTY: f32 = 8.0;

/// Number of ticks that the removal happiness penalty lasts.
pub const REMOVAL_PENALTY_DURATION_TICKS: u32 = 300;

// =============================================================================
// Resource: Historic Preservation State
// =============================================================================

/// Tracks which player-defined districts have historic preservation enabled,
/// and any active removal penalties.
#[derive(Resource, Debug, Clone, Default, Encode, Decode)]
pub struct HistoricPreservationState {
    /// Set of district indices that have historic preservation enabled.
    pub preserved_districts: HashSet<usize>,
    /// Active removal penalties: (district_index, remaining_ticks).
    pub removal_penalties: Vec<(usize, u32)>,
    /// Total tourism visitors generated by historic districts this period.
    pub historic_tourism_visitors: u32,
}

impl HistoricPreservationState {
    /// Check if a district is designated as a historic preservation district.
    pub fn is_preserved(&self, district_idx: usize) -> bool {
        self.preserved_districts.contains(&district_idx)
    }

    /// Designate a district as historic preservation.
    pub fn designate(&mut self, district_idx: usize) {
        self.preserved_districts.insert(district_idx);
    }

    /// Remove historic preservation from a district, triggering a removal penalty.
    pub fn remove(&mut self, district_idx: usize) {
        if self.preserved_districts.remove(&district_idx) {
            self.removal_penalties
                .push((district_idx, REMOVAL_PENALTY_DURATION_TICKS));
        }
    }

    /// Check if a cell at (x, y) is in a historic preservation district.
    pub fn is_cell_preserved(&self, x: usize, y: usize, district_map: &DistrictMap) -> bool {
        if let Some(di) = district_map.get_district_index_at(x, y) {
            self.preserved_districts.contains(&di)
        } else {
            false
        }
    }

    /// Get the current happiness penalty from removal events.
    pub fn removal_happiness_penalty(&self) -> f32 {
        if self.removal_penalties.is_empty() {
            return 0.0;
        }
        // Each active removal contributes a decaying penalty
        let mut total = 0.0_f32;
        for &(_, remaining) in &self.removal_penalties {
            let fraction = remaining as f32 / REMOVAL_PENALTY_DURATION_TICKS as f32;
            total += PRESERVATION_REMOVAL_HAPPINESS_PENALTY * fraction;
        }
        total
    }
}

// =============================================================================
// Pure helper functions (testable without ECS)
// =============================================================================

/// Calculate the land value bonus for a cell in a historic district.
/// Returns the bonus as an integer to add to the current land value.
pub fn historic_land_value_bonus(current_value: u8) -> i32 {
    (current_value as f32 * HISTORIC_LAND_VALUE_BONUS) as i32
}

/// Calculate tourism visitors from historic districts.
pub fn calculate_historic_tourism(num_preserved_districts: usize) -> u32 {
    num_preserved_districts as u32 * HISTORIC_TOURISM_VISITORS_PER_DISTRICT
}

/// Check if a building should be protected from upgrade/demolition.
pub fn is_building_protected(
    building_x: usize,
    building_y: usize,
    state: &HistoricPreservationState,
    district_map: &DistrictMap,
) -> bool {
    state.is_cell_preserved(building_x, building_y, district_map)
}
