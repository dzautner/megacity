//! CSO types, constants, and data structures.
//!
//! Contains the core constants, `SewerType` enum, `SewerSystemState` resource,
//! and `CsoEvent` Bevy event used throughout the CSO subsystem.

use bevy::prelude::*;
use serde::{Deserialize, Serialize};

// =============================================================================
// Constants
// =============================================================================

/// Average sewage flow per person per day, in gallons.
pub const GALLONS_PER_CAPITA_PER_DAY: f32 = 80.0;

/// Combined sewer capacity per road cell, in gallons per hour.
pub const BASE_COMBINED_CAPACITY_PER_CELL: f32 = 10_000.0;

/// Fraction of stormwater runoff that enters the combined sewer system.
/// The rest flows overland or into separate storm drains.
pub const STORMWATER_TO_SEWER_FACTOR: f32 = 0.5;

/// Pollution units generated per gallon of untreated CSO discharge.
pub const POLLUTION_PER_GALLON_CSO: f32 = 0.0001;

/// Cost in dollars to separate one grid cell from combined to separated sewer.
pub const SEPARATION_COST_PER_CELL: f32 = 500_000.0;

// =============================================================================
// SewerType enum
// =============================================================================

/// Whether the city uses a combined or separated sewer system.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SewerType {
    /// Single pipe carries both sewage and stormwater. Prone to CSO during storms.
    #[default]
    Combined,
    /// Separate pipes for sewage and stormwater. No CSO risk.
    Separated,
}

// =============================================================================
// SewerSystemState resource
// =============================================================================

/// City-wide sewer system state, tracking capacity, flow, and CSO events.
#[derive(Resource, Clone, Debug, Serialize, Deserialize)]
pub struct SewerSystemState {
    /// Whether the city primarily uses combined or separated sewers.
    pub sewer_type: SewerType,
    /// Total combined sewer capacity in gallons per hour.
    pub combined_capacity: f32,
    /// Current combined flow (sewage + stormwater inflow) in gallons per hour.
    pub current_flow: f32,
    /// Whether a CSO event is currently active (flow exceeds capacity).
    pub cso_active: bool,
    /// Gallons of untreated discharge this tick.
    pub cso_discharge_gallons: f32,
    /// Cumulative total CSO events since city founding.
    pub cso_events_total: u32,
    /// CSO events this calendar year (reset annually).
    pub cso_events_this_year: u32,
    /// Number of grid cells that have been upgraded to separated sewers.
    pub cells_with_separated_sewer: u32,
    /// Total number of sewer-serviced cells (road cells).
    pub total_sewer_cells: u32,
    /// Fraction of sewer cells that are separated (0.0..=1.0).
    pub separation_coverage: f32,
    /// Total gallons of CSO discharge this calendar year.
    pub annual_cso_volume: f32,
    /// Pollution units contributed by CSO this tick.
    pub pollution_contribution: f32,
}

impl Default for SewerSystemState {
    fn default() -> Self {
        Self {
            sewer_type: SewerType::Combined,
            combined_capacity: 0.0,
            current_flow: 0.0,
            cso_active: false,
            cso_discharge_gallons: 0.0,
            cso_events_total: 0,
            cso_events_this_year: 0,
            cells_with_separated_sewer: 0,
            total_sewer_cells: 0,
            separation_coverage: 0.0,
            annual_cso_volume: 0.0,
            pollution_contribution: 0.0,
        }
    }
}

// =============================================================================
// CsoEvent (Bevy Event)
// =============================================================================

/// Bevy event fired when a Combined Sewer Overflow occurs.
///
/// Downstream systems can listen for this event to apply water pollution,
/// trigger UI notifications, or update environmental compliance records.
#[derive(Event, Debug, Clone)]
pub struct CsoEvent {
    /// Gallons of untreated sewage+stormwater discharged.
    pub discharge_gallons: f32,
    /// Pollution units generated by this discharge.
    pub pollution_units: f32,
}

#[cfg(test)]
mod tests {
    use super::*;

    // -------------------------------------------------------------------------
    // SewerType tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_sewer_type_default_is_combined() {
        assert_eq!(SewerType::default(), SewerType::Combined);
    }

    #[test]
    fn test_sewer_type_equality() {
        assert_eq!(SewerType::Combined, SewerType::Combined);
        assert_eq!(SewerType::Separated, SewerType::Separated);
        assert_ne!(SewerType::Combined, SewerType::Separated);
    }

    #[test]
    fn test_sewer_type_clone() {
        let t = SewerType::Separated;
        let t2 = t;
        assert_eq!(t, t2);
    }

    #[test]
    fn test_sewer_type_serde_roundtrip() {
        let combined = SewerType::Combined;
        let json = serde_json::to_string(&combined).expect("serialize");
        let deserialized: SewerType = serde_json::from_str(&json).expect("deserialize");
        assert_eq!(deserialized, SewerType::Combined);

        let separated = SewerType::Separated;
        let json = serde_json::to_string(&separated).expect("serialize");
        let deserialized: SewerType = serde_json::from_str(&json).expect("deserialize");
        assert_eq!(deserialized, SewerType::Separated);
    }

    // -------------------------------------------------------------------------
    // SewerSystemState default tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_sewer_state_default() {
        let state = SewerSystemState::default();
        assert_eq!(state.sewer_type, SewerType::Combined);
        assert_eq!(state.combined_capacity, 0.0);
        assert_eq!(state.current_flow, 0.0);
        assert!(!state.cso_active);
        assert_eq!(state.cso_discharge_gallons, 0.0);
        assert_eq!(state.cso_events_total, 0);
        assert_eq!(state.cso_events_this_year, 0);
        assert_eq!(state.cells_with_separated_sewer, 0);
        assert_eq!(state.total_sewer_cells, 0);
        assert_eq!(state.separation_coverage, 0.0);
        assert_eq!(state.annual_cso_volume, 0.0);
        assert_eq!(state.pollution_contribution, 0.0);
    }

    #[test]
    fn test_sewer_state_clone() {
        let mut state = SewerSystemState::default();
        state.cso_events_total = 7;
        state.combined_capacity = 100_000.0;
        state.cso_active = true;
        let cloned = state.clone();
        assert_eq!(cloned.cso_events_total, 7);
        assert_eq!(cloned.combined_capacity, 100_000.0);
        assert!(cloned.cso_active);
    }

    #[test]
    fn test_sewer_state_serde_roundtrip() {
        let state = SewerSystemState {
            sewer_type: SewerType::Combined,
            combined_capacity: 500_000.0,
            current_flow: 300_000.0,
            cso_active: true,
            cso_discharge_gallons: 50_000.0,
            cso_events_total: 12,
            cso_events_this_year: 3,
            cells_with_separated_sewer: 100,
            total_sewer_cells: 400,
            separation_coverage: 0.25,
            annual_cso_volume: 150_000.0,
            pollution_contribution: 5.0,
        };

        let json = serde_json::to_string(&state).expect("serialize");
        let deserialized: SewerSystemState = serde_json::from_str(&json).expect("deserialize");

        assert_eq!(deserialized.sewer_type, SewerType::Combined);
        assert!((deserialized.combined_capacity - 500_000.0).abs() < f32::EPSILON);
        assert!((deserialized.current_flow - 300_000.0).abs() < f32::EPSILON);
        assert!(deserialized.cso_active);
        assert!((deserialized.cso_discharge_gallons - 50_000.0).abs() < f32::EPSILON);
        assert_eq!(deserialized.cso_events_total, 12);
        assert_eq!(deserialized.cso_events_this_year, 3);
        assert_eq!(deserialized.cells_with_separated_sewer, 100);
        assert_eq!(deserialized.total_sewer_cells, 400);
        assert!((deserialized.separation_coverage - 0.25).abs() < f32::EPSILON);
        assert!((deserialized.annual_cso_volume - 150_000.0).abs() < f32::EPSILON);
        assert!((deserialized.pollution_contribution - 5.0).abs() < f32::EPSILON);
    }

    // -------------------------------------------------------------------------
    // Constants tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_constants_positive() {
        assert!(GALLONS_PER_CAPITA_PER_DAY > 0.0);
        assert!(BASE_COMBINED_CAPACITY_PER_CELL > 0.0);
        assert!(STORMWATER_TO_SEWER_FACTOR > 0.0);
        assert!(STORMWATER_TO_SEWER_FACTOR <= 1.0);
        assert!(POLLUTION_PER_GALLON_CSO > 0.0);
        assert!(SEPARATION_COST_PER_CELL > 0.0);
    }

    #[test]
    fn test_gallons_per_capita_per_day_value() {
        assert!((GALLONS_PER_CAPITA_PER_DAY - 80.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_base_combined_capacity_per_cell_value() {
        assert!((BASE_COMBINED_CAPACITY_PER_CELL - 10_000.0).abs() < f32::EPSILON);
    }

    #[test]
    fn test_stormwater_to_sewer_factor_value() {
        assert!((STORMWATER_TO_SEWER_FACTOR - 0.5).abs() < f32::EPSILON);
    }

    #[test]
    fn test_pollution_per_gallon_cso_value() {
        assert!((POLLUTION_PER_GALLON_CSO - 0.0001).abs() < f32::EPSILON);
    }

    #[test]
    fn test_separation_cost_per_cell_value() {
        assert!((SEPARATION_COST_PER_CELL - 500_000.0).abs() < f32::EPSILON);
    }

    // -------------------------------------------------------------------------
    // CsoEvent tests
    // -------------------------------------------------------------------------

    #[test]
    fn test_cso_event_construction() {
        let event = CsoEvent {
            discharge_gallons: 25_000.0,
            pollution_units: 2.5,
        };
        assert!((event.discharge_gallons - 25_000.0).abs() < f32::EPSILON);
        assert!((event.pollution_units - 2.5).abs() < f32::EPSILON);
    }

    #[test]
    fn test_cso_event_clone() {
        let event = CsoEvent {
            discharge_gallons: 10_000.0,
            pollution_units: 1.0,
        };
        let cloned = event.clone();
        assert!((cloned.discharge_gallons - 10_000.0).abs() < f32::EPSILON);
        assert!((cloned.pollution_units - 1.0).abs() < f32::EPSILON);
    }
}
