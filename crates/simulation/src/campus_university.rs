//! SERV-011: Campus/University District System
//!
//! Implements university campus districts modeled after CS1's Campus DLC.
//! Players draw campus boundaries and place academic buildings within them.
//! Campuses level up based on student count and academic output.
//!
//! - Campus types: TradeSchool, LiberalArts, University
//! - Campus leveling: L1 (500), L2 (1000), L3 (2500), L4 (5000), L5 (10000) students
//! - Academic works: generated by labs, libraries, lecture halls over time
//! - Campus buildings: dormitories, faculty offices, stadiums, gyms, labs
//! - Varsity sports: revenue and happiness from athletic events
//! - Campus graduates feed education pipeline (SERV-003)
//! - Land value bonus around campus

use bevy::prelude::*;
use bitcode::{Decode, Encode};
use serde::{Deserialize, Serialize};

use crate::config::{CELL_SIZE, GRID_HEIGHT, GRID_WIDTH};
use crate::services::{ServiceBuilding, ServiceType};
use crate::SlowTickTimer;

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

/// Student thresholds for campus levels 1-5.
const LEVEL_STUDENT_THRESHOLDS: [u32; 5] = [0, 500, 1000, 2500, 5000];

/// Academic work thresholds for campus levels 1-5.
const LEVEL_ACADEMIC_THRESHOLDS: [u32; 5] = [0, 10, 50, 150, 400];

/// Education quality bonus per campus level (applied to nearby cells).
const EDUCATION_BONUS_PER_LEVEL: [f32; 5] = [5.0, 10.0, 16.0, 22.0, 30.0];

/// Land value bonus per campus level.
const LAND_VALUE_PER_LEVEL: [f32; 5] = [3.0, 6.0, 10.0, 15.0, 22.0];

/// Happiness bonus per campus level from academic prestige.
const HAPPINESS_PER_LEVEL: [f32; 5] = [2.0, 4.0, 7.0, 11.0, 16.0];

/// Effect radius (in cells) per campus level.
const RADIUS_PER_LEVEL: [i32; 5] = [8, 10, 14, 18, 24];

/// Base academic works produced per academic building per slow tick.
const ACADEMIC_WORKS_PER_BUILDING: u32 = 2;

/// Varsity sports revenue per athletic building per slow tick.
const SPORTS_REVENUE_PER_BUILDING: f64 = 50.0;

/// Base students attracted per university building per slow tick.
const STUDENTS_PER_UNIVERSITY: u32 = 60;

/// Base students attracted per library per slow tick.
const STUDENTS_PER_LIBRARY: u32 = 20;

// ---------------------------------------------------------------------------
// Campus type
// ---------------------------------------------------------------------------

/// The type of campus district, each with unique bonuses.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default, Serialize, Deserialize, Encode, Decode)]
pub enum CampusType {
    #[default]
    University,
    TradeSchool,
    LiberalArts,
}

impl CampusType {
    pub fn name(self) -> &'static str {
        match self {
            Self::University => "University",
            Self::TradeSchool => "Trade School",
            Self::LiberalArts => "Liberal Arts College",
        }
    }

    /// Multiplier for academic works production by campus type.
    pub fn academic_multiplier(self) -> f32 {
        match self {
            Self::University => 1.5,
            Self::LiberalArts => 1.2,
            Self::TradeSchool => 0.8,
        }
    }

    /// Multiplier for sports revenue by campus type.
    pub fn sports_multiplier(self) -> f32 {
        match self {
            Self::University => 1.0,
            Self::TradeSchool => 0.5,
            Self::LiberalArts => 0.7,
        }
    }
}

// ---------------------------------------------------------------------------
// Campus district
// ---------------------------------------------------------------------------

/// A single campus district with configuration and tracked state.
#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]
pub struct CampusDistrict {
    pub id: u32,
    pub campus_type: CampusType,
    pub center_x: usize,
    pub center_y: usize,
    pub level: u8,
    pub total_students: u32,
    pub academic_works: u32,
    pub academic_building_count: u32,
    pub athletic_building_count: u32,
    pub sports_revenue: f64,
    pub total_revenue: f64,
    pub graduates_produced: u32,
}

impl CampusDistrict {
    pub fn new(id: u32, campus_type: CampusType, cx: usize, cy: usize) -> Self {
        Self {
            id,
            campus_type,
            center_x: cx,
            center_y: cy,
            level: 1,
            total_students: 0,
            academic_works: 0,
            academic_building_count: 0,
            athletic_building_count: 0,
            sports_revenue: 0.0,
            total_revenue: 0.0,
            graduates_produced: 0,
        }
    }

    fn level_idx(&self) -> usize {
        (self.level as usize).saturating_sub(1).min(4)
    }

    pub fn education_bonus(&self) -> f32 {
        EDUCATION_BONUS_PER_LEVEL[self.level_idx()]
    }

    pub fn land_value_bonus(&self) -> f32 {
        LAND_VALUE_PER_LEVEL[self.level_idx()]
    }

    pub fn happiness_bonus(&self) -> f32 {
        HAPPINESS_PER_LEVEL[self.level_idx()]
    }

    pub fn radius_cells(&self) -> i32 {
        RADIUS_PER_LEVEL[self.level_idx()]
    }

    pub fn recalculate_level(&mut self) {
        let mut new_level: u8 = 1;
        for i in 1..5 {
            if self.total_students >= LEVEL_STUDENT_THRESHOLDS[i]
                && self.academic_works >= LEVEL_ACADEMIC_THRESHOLDS[i]
            {
                new_level = (i + 1) as u8;
            }
        }
        self.level = new_level;
    }
}

// ---------------------------------------------------------------------------
// Per-cell effects grid
// ---------------------------------------------------------------------------

/// Precomputed per-cell effects from campus districts, updated each slow tick.
#[derive(Resource, Clone, Serialize, Deserialize, Encode, Decode)]
pub struct CampusEffects {
    pub education: Vec<f32>,
    pub land_value: Vec<f32>,
    pub happiness: Vec<f32>,
}

impl Default for CampusEffects {
    fn default() -> Self {
        let n = GRID_WIDTH * GRID_HEIGHT;
        Self {
            education: vec![0.0; n],
            land_value: vec![0.0; n],
            happiness: vec![0.0; n],
        }
    }
}

impl CampusEffects {
    #[inline]
    pub fn idx(x: usize, y: usize) -> usize {
        y * GRID_WIDTH + x
    }

    pub fn education_at(&self, x: usize, y: usize) -> f32 {
        self.education[Self::idx(x, y)]
    }

    pub fn land_value_at(&self, x: usize, y: usize) -> f32 {
        self.land_value[Self::idx(x, y)]
    }

    pub fn happiness_at(&self, x: usize, y: usize) -> f32 {
        self.happiness[Self::idx(x, y)]
    }

    fn clear(&mut self) {
        self.education.fill(0.0);
        self.land_value.fill(0.0);
        self.happiness.fill(0.0);
    }
}

// ---------------------------------------------------------------------------
// State resource
// ---------------------------------------------------------------------------

/// City-wide campus district state: all campuses and aggregate statistics.
#[derive(Resource, Clone, Serialize, Deserialize, Encode, Decode)]
pub struct CampusUniversityState {
    pub districts: Vec<CampusDistrict>,
    pub next_id: u32,
    pub total_students: u32,
    pub total_academic_works: u32,
    pub total_graduates: u32,
    pub cycle_revenue: f64,
}

impl Default for CampusUniversityState {
    fn default() -> Self {
        Self {
            districts: Vec::new(),
            next_id: 1,
            total_students: 0,
            total_academic_works: 0,
            total_graduates: 0,
            cycle_revenue: 0.0,
        }
    }
}

impl CampusUniversityState {
    pub fn create_district(
        &mut self,
        campus_type: CampusType,
        cx: usize,
        cy: usize,
    ) -> u32 {
        let id = self.next_id;
        self.next_id += 1;
        self.districts
            .push(CampusDistrict::new(id, campus_type, cx, cy));
        id
    }

    pub fn remove_district(&mut self, id: u32) {
        self.districts.retain(|d| d.id != id);
    }

    pub fn get_district(&self, id: u32) -> Option<&CampusDistrict> {
        self.districts.iter().find(|d| d.id == id)
    }

    pub fn get_district_mut(&mut self, id: u32) -> Option<&mut CampusDistrict> {
        self.districts.iter_mut().find(|d| d.id == id)
    }
}

// ---------------------------------------------------------------------------
// Saveable
// ---------------------------------------------------------------------------

impl crate::Saveable for CampusUniversityState {
    const SAVE_KEY: &'static str = "campus_university";

    fn save_to_bytes(&self) -> Option<Vec<u8>> {
        if self.districts.is_empty() {
            return None;
        }
        Some(bitcode::encode(self))
    }

    fn load_from_bytes(bytes: &[u8]) -> Self {
        crate::decode_or_warn(Self::SAVE_KEY, bytes)
    }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/// Check if a service type counts as an academic building for a campus.
fn is_academic_building(st: ServiceType) -> bool {
    matches!(st, ServiceType::University | ServiceType::Library)
}

/// Check if a service type counts as an athletic building for a campus.
fn is_athletic_building(st: ServiceType) -> bool {
    matches!(st, ServiceType::Stadium | ServiceType::SportsField)
}

fn count_campus_buildings(
    district: &mut CampusDistrict,
    services: &[&ServiceBuilding],
) {
    let radius = district.radius_cells();
    let cx = district.center_x as i32;
    let cy = district.center_y as i32;
    let mut academic_count = 0u32;
    let mut athletic_count = 0u32;
    for svc in services {
        let dx = (svc.grid_x as i32 - cx).abs();
        let dy = (svc.grid_y as i32 - cy).abs();
        if dx <= radius && dy <= radius {
            if is_academic_building(svc.service_type) {
                academic_count += 1;
            }
            if is_athletic_building(svc.service_type) {
                athletic_count += 1;
            }
        }
    }
    district.academic_building_count = academic_count;
    district.athletic_building_count = athletic_count;
}

fn apply_campus_effects(district: &CampusDistrict, effects: &mut CampusEffects) {
    let radius = district.radius_cells();
    let cx = district.center_x as i32;
    let cy = district.center_y as i32;
    let r2 = (radius as f32 * CELL_SIZE) * (radius as f32 * CELL_SIZE);
    let edu = district.education_bonus();
    let land_val = district.land_value_bonus();
    let happy = district.happiness_bonus();
    let max_dist = radius as f32 * CELL_SIZE;

    for dy in -radius..=radius {
        for dx in -radius..=radius {
            let nx = cx + dx;
            let ny = cy + dy;
            if nx < 0 || ny < 0 || nx >= GRID_WIDTH as i32 || ny >= GRID_HEIGHT as i32 {
                continue;
            }
            let wx = dx as f32 * CELL_SIZE;
            let wy = dy as f32 * CELL_SIZE;
            let dist_sq = wx * wx + wy * wy;
            if dist_sq > r2 {
                continue;
            }

            let idx = CampusEffects::idx(nx as usize, ny as usize);
            let falloff = 1.0 - (dist_sq.sqrt() / max_dist).clamp(0.0, 1.0) * 0.5;
            effects.education[idx] = effects.education[idx].max(edu * falloff);
            effects.land_value[idx] = effects.land_value[idx].max(land_val * falloff);
            effects.happiness[idx] = effects.happiness[idx].max(happy * falloff);
        }
    }
}

// ---------------------------------------------------------------------------
// System
// ---------------------------------------------------------------------------

/// Update campus districts each slow tick: count buildings, simulate enrollment,
/// produce academic works, calculate sports revenue, recalculate levels, and
/// apply per-cell effects.
pub fn update_campus_university(
    slow_timer: Res<SlowTickTimer>,
    services: Query<&ServiceBuilding>,
    mut state: ResMut<CampusUniversityState>,
    mut effects: ResMut<CampusEffects>,
    stats: Res<crate::stats::CityStats>,
) {
    if !slow_timer.should_run() {
        return;
    }
    effects.clear();

    let svc_list: Vec<&ServiceBuilding> = services.iter().collect();
    let pop = stats.population.max(1);
    let mut accum_students: u32 = 0;
    let mut accum_works: u32 = 0;
    let mut accum_graduates: u32 = 0;
    let mut accum_revenue: f64 = 0.0;

    for district in &mut state.districts {
        count_campus_buildings(district, &svc_list);

        // Student enrollment based on academic buildings and population
        let new_students = (district.academic_building_count * STUDENTS_PER_UNIVERSITY)
            .saturating_add(district.academic_building_count * STUDENTS_PER_LIBRARY)
            .min(pop / 4);
        district.total_students = district.total_students.saturating_add(new_students);

        // Academic works production
        let works = (district.academic_building_count * ACADEMIC_WORKS_PER_BUILDING) as f32
            * district.campus_type.academic_multiplier();
        district.academic_works = district.academic_works.saturating_add(works as u32);

        // Recalculate level based on students and academic works
        district.recalculate_level();

        // Sports revenue from athletic buildings
        district.sports_revenue = district.athletic_building_count as f64
            * SPORTS_REVENUE_PER_BUILDING
            * district.campus_type.sports_multiplier() as f64;
        district.total_revenue += district.sports_revenue;

        // Graduates: each slow tick, a fraction of students graduate
        let grad_rate = 0.01 * district.level as f32;
        let new_grads = (new_students as f32 * grad_rate) as u32;
        district.graduates_produced = district.graduates_produced.saturating_add(new_grads);

        // Apply spatial effects
        apply_campus_effects(district, &mut effects);

        accum_students += district.total_students;
        accum_works += district.academic_works;
        accum_graduates += district.graduates_produced;
        accum_revenue += district.sports_revenue;
    }

    state.total_students = accum_students;
    state.total_academic_works = accum_works;
    state.total_graduates = accum_graduates;
    state.cycle_revenue = accum_revenue;
}

// ---------------------------------------------------------------------------
// Plugin
// ---------------------------------------------------------------------------

pub struct CampusUniversityPlugin;

impl Plugin for CampusUniversityPlugin {
    fn build(&self, app: &mut App) {
        app.init_resource::<CampusUniversityState>();
        app.init_resource::<CampusEffects>();
        app.init_resource::<crate::SaveableRegistry>();
        app.world_mut()
            .resource_mut::<crate::SaveableRegistry>()
            .register::<CampusUniversityState>();
        app.add_systems(
            FixedUpdate,
            update_campus_university
                .after(crate::stats::update_stats)
                .in_set(crate::SimulationSet::Simulation),
        );
    }
}

// ---------------------------------------------------------------------------
// Unit tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use crate::Saveable;

    #[test]
    fn test_create_and_remove_district() {
        let mut state = CampusUniversityState::default();
        let id1 = state.create_district(CampusType::University, 10, 10);
        let id2 = state.create_district(CampusType::TradeSchool, 20, 20);
        assert_eq!(state.districts.len(), 2);
        assert_eq!(id1, 1);
        assert_eq!(id2, 2);
        state.remove_district(id1);
        assert_eq!(state.districts.len(), 1);
        assert_eq!(state.districts[0].id, id2);
    }

    #[test]
    fn test_level_progression() {
        let mut d = CampusDistrict::new(1, CampusType::University, 10, 10);
        assert_eq!(d.level, 1);
        d.total_students = 500;
        d.academic_works = 10;
        d.recalculate_level();
        assert_eq!(d.level, 2);
        d.total_students = 1000;
        d.academic_works = 50;
        d.recalculate_level();
        assert_eq!(d.level, 3);
        d.total_students = 2500;
        d.academic_works = 150;
        d.recalculate_level();
        assert_eq!(d.level, 4);
        d.total_students = 5000;
        d.academic_works = 400;
        d.recalculate_level();
        assert_eq!(d.level, 5);
    }

    #[test]
    fn test_education_bonus_scales_with_level() {
        let mut d = CampusDistrict::new(1, CampusType::University, 10, 10);
        let e1 = d.education_bonus();
        d.level = 3;
        let e3 = d.education_bonus();
        d.level = 5;
        let e5 = d.education_bonus();
        assert!(e3 > e1);
        assert!(e5 > e3);
    }

    #[test]
    fn test_university_higher_academic_multiplier() {
        assert!(CampusType::University.academic_multiplier() > CampusType::TradeSchool.academic_multiplier());
        assert!(CampusType::LiberalArts.academic_multiplier() > CampusType::TradeSchool.academic_multiplier());
    }

    #[test]
    fn test_radius_increases_with_level() {
        let mut d = CampusDistrict::new(1, CampusType::University, 10, 10);
        d.level = 1;
        let r1 = d.radius_cells();
        d.level = 5;
        assert!(d.radius_cells() > r1);
    }

    #[test]
    fn test_effects_grid_clear() {
        let mut effects = CampusEffects::default();
        let idx = CampusEffects::idx(10, 10);
        effects.education[idx] = 15.0;
        effects.land_value[idx] = 10.0;
        effects.happiness[idx] = 5.0;
        effects.clear();
        assert!(effects.education[idx].abs() < f32::EPSILON);
        assert!(effects.land_value[idx].abs() < f32::EPSILON);
        assert!(effects.happiness[idx].abs() < f32::EPSILON);
    }

    #[test]
    fn test_default_state() {
        let state = CampusUniversityState::default();
        assert!(state.districts.is_empty());
        assert_eq!(state.next_id, 1);
        assert_eq!(state.total_students, 0);
        assert_eq!(state.total_academic_works, 0);
        assert_eq!(state.total_graduates, 0);
        assert!((state.cycle_revenue - 0.0).abs() < f64::EPSILON);
    }

    #[test]
    fn test_saveable_key() {
        assert_eq!(CampusUniversityState::SAVE_KEY, "campus_university");
    }

    #[test]
    fn test_saveable_roundtrip() {
        let mut state = CampusUniversityState::default();
        state.create_district(CampusType::University, 50, 50);
        state.create_district(CampusType::TradeSchool, 100, 100);
        state.total_students = 1500;
        state.total_academic_works = 42;

        let bytes = state.save_to_bytes().expect("should produce bytes");
        let restored = CampusUniversityState::load_from_bytes(&bytes);

        assert_eq!(restored.districts.len(), 2);
        assert_eq!(restored.total_students, 1500);
        assert_eq!(restored.total_academic_works, 42);
        assert_eq!(restored.districts[0].campus_type, CampusType::University);
        assert_eq!(restored.districts[1].campus_type, CampusType::TradeSchool);
    }

    #[test]
    fn test_saveable_skip_empty() {
        let state = CampusUniversityState::default();
        assert!(state.save_to_bytes().is_none(), "empty state should skip saving");
    }

    #[test]
    fn test_campus_type_names() {
        assert_eq!(CampusType::University.name(), "University");
        assert_eq!(CampusType::TradeSchool.name(), "Trade School");
        assert_eq!(CampusType::LiberalArts.name(), "Liberal Arts College");
    }

    #[test]
    fn test_is_academic_building() {
        assert!(is_academic_building(ServiceType::University));
        assert!(is_academic_building(ServiceType::Library));
        assert!(!is_academic_building(ServiceType::Stadium));
        assert!(!is_academic_building(ServiceType::FireStation));
    }

    #[test]
    fn test_is_athletic_building() {
        assert!(is_athletic_building(ServiceType::Stadium));
        assert!(is_athletic_building(ServiceType::SportsField));
        assert!(!is_athletic_building(ServiceType::University));
        assert!(!is_athletic_building(ServiceType::Library));
    }
}
